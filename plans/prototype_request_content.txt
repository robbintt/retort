
#### Let's write plans/prototype.md. This will be a markdown file of tasks, which gets us from 0 to 1 in retort.  Retort is an AI pair programmer. Our early emphasis will be intelligent, stateless, session management, while storing session state in a local sqlite database.  We will have a config file where we can specify the location for the sqlite database, but the default will be ~/.retort/data/retort.db  Session management means that we can specify a session as the starting point for any action.  We won't have any UI at all to start with, instead, we will work from the CLI, sending a command with flags that will include the next message to the LLM. The response will be streamed to stdout and also processed and parsed for fenced changes, which will be applied to the codebase. The first way we will apply the changes will be git, then we will follow up with jj. The other early emphasis will be on prompt building. It's very important to know what prompt we are putting in every step of the way.  
####   
#### Our early work will be heavily influenced by aider. During prototyping I will be using prompts directly from Aider.  After initial prototyping I will use prompt optimization techniques like dspy, opro, or ape. This will be determined at that time. The important thing is that the builder be isolated.  
####   
#### The first things we need to do are select a reliable rust CLI tooling, select the rust sqlite database client, make a model for the session management, get the prompt builder working with a templating system such as jinja, and get a llm client library working with Gemini pro, flash, and flash-lite, which will be our main test LLM.  
####   
#### We also want good test coverage on any permanent element, which means the client library, the database, the session manager, and the CLI, and the config, we can have 1 test for the prompt templating since it's not the most urgent priority.  
####   
#### Once we are able to submit a message by CLI, e.g. "rt -m Please implement the xyz function stub in asdf.rs" then we can reprioritize.  
####   
#### In the sessions, we have the message history, we also have read-only files, read-write files, and the model sent for each message.  We will also want to reproduce the repo map feature from aider, which is very nice, it uses tree-sitter, which we can probably get in rust.  
####   
#### I will plan to implement each component as a hook, and we will allow for optional configuration of the hooks in the config, but the default hooks will be supplied by the application.  For example, processing the LLM response would be a hook point, and our parser would be one of the hooks for that, and then after the parser, the process of storing the changes, such as git commit or the jj equivalent would also be a hook, but it might be called by the parser, more likely the parser would store its parsed data in the database and then the git or jj hook would run after and query the content then apply it. That way if something failed, we could retry the git event with the db contents.  
####   
#### Go ahead and get all this content into plans/prototype.md for now. Please use a phase per implementation component, order the phases by e2e, e.g we want the cli first so we can just reflect the message, then the db to store messages, then we want the prompt builder, finally we want the llm client. I may have left something off, if so add it in the right place.  
