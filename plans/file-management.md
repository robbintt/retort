The coding partner is working end to end.  We have a concept of messages and history, and we're tracking the metadata about the prompts we use. This is all very good.  The next step is to have some notion of adding files to the context in the prompt templates from the prompts/ folder.  There are a few challenges I want to consider. Our conversation tag should become a way for us to carry over state to the next message.  State includes the "registered repo" which is the git repository we are contributing code to, and actually, why not just one. But we will leave it one for now and think about extending git repo count later.  We don't want to be git-first, so that means registration is more about registering a project root for editing files. We should not edit files outside the project root, especially applying edits, we should have a specific check for that.

So, we need to "add files to the chat" -- what exactly does that mean? It means the filepath+filename is in a list of files that will be added to the template at runtime.  It's important that the files are added right when the message is sent in case the user makes last minute edits or commits.

For readonly files, they have an absolute filepath and should never be edited during a chat round with the LLM. The prompting already takes care of the instructions, we need to ensure that the specific check mentioned above works in our integration tests. We should also support readonly files INSIDE the currently regisetered project path. These are also read right before the message is sent.

In practice that just means the template is composed into the message after the user does the "send" command, while the send command is being executed.

When adding files to the prompt, read-only files should be added in order they are added to the chat, so we append the filepath to the list. This ensures better caching. The read-write files should also be added in this order, it will be good to give the user predictable behavior so they can try to optimize caching and get a consistent LLM response between messages. We do not want alphabetical, which causes file placement to shift during the conversation.

We need to store the filepath+filename and their hashes in the message metadata, separately for read-write and read-only files. This should be stored as an array which is the order the files were included in the prompt.

How will we store the filepaths between messages? Today we use the active chat tag to give the user a default message thread to submit a new message to. I don't think we need to use this tag for files.  Instead, we can have a notion of a "context". The context for the next message in a thread is the previous message context, plus or minus any differences the user requests. So, for a new message, the context is empty plus the differences the user adds. In this case our only context is readwrite files and readonly files.  However, in the future we could have dedicated sections of the prompt for tool calls, which could also supply ongoing or one time context.  But readonly files and readwrite files will carry over by default to the next message.

The question then is how we have the "staging" or "staged" context.  And should we have multiple named staged contexts? Once a staged context is used, we don't need to keep it around necessarily, it becomes the "inherited" context for the next message. However, the user might like to have it to rerun the message.

So, my first impression is that we have a "context stage" for the next message, which includes the last message and its "inherited context".  We don't need to register a new stage. For now let's have a "context_stages" table with only 1 row named "default". Later on we can allow the user to switch stages.  The mechanism will be that the user can add files to this stage record as read write or read only, and whatever message they send will apply the stage to the prompt template when the message is submitted.  The stored user message metadata includes the stage contents, but also adds the file hashes for reproducibility later.   Then, the stage is cleared.  But, the user by default will be using a tagged message, which means the next message will get the last "stage" in the "inherited stage".  In this way, the stage will accumulate over the chat.

So, I guess the user needs a command `retort stage file <myfile>` which is implicit --read-write/-w and `retort stage file <myfile> --read-only/-r
And they need a command `retort stage file <myfile> --drop/-d` which will drop the file from the stage, e.g. it may be dropped from the inherited stage or it may be added to and then dropped from the working stage.
